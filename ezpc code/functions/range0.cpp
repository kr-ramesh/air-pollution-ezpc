/*
This is an autogenerated file, generated using the EzPC compiler.
*/

#include "emp-sh2pc/emp-sh2pc.h" 
using namespace emp;
using namespace std;
int bitlen = 32;
int party,port;
char *ip = "127.0.0.1"; 
template<typename T> 
vector<T> make_vector(size_t size) { 
return std::vector<T>(size); 
} 

template <typename T, typename... Args> 
auto make_vector(size_t first, Args... sizes) 
{ 
auto inner = make_vector<T>(sizes...); 
return vector<decltype(inner)>(first, inner); 
} 

const uint32_t dim =  (int32_t)4;

Bit check1(auto& x2, Integer threshold){

Bit result;

Integer count = Integer(bitlen,  (int32_t)0, PUBLIC);
for (uint32_t i =  (int32_t)0; i <  (int32_t)4; i++){
/* Temporary variable for sub-expression on source location: (9,22-9,27) */
Bit __tac_var1 = x2[i];
/* Temporary variable for sub-expression on source location: (9,31-9,32) */
Integer __tac_var2 = Integer(bitlen,  (int32_t)1, PUBLIC);
/* Temporary variable for sub-expression on source location: (9,35-9,36) */
Integer __tac_var3 = Integer(bitlen,  (int32_t)0, PUBLIC);
/* Temporary variable for sub-expression on source location: (9,21-9,36) */
Integer __tac_var4 =  If(__tac_var1, __tac_var2, __tac_var3);
count = count.operator+(__tac_var4);
}
result = count.operator>(threshold);
return result;
}

Integer count(auto& x1, auto& x2, Integer threshold1, Integer threshold2){

Integer resultfinal = Integer(bitlen,  (int32_t)0, PUBLIC);
for (uint32_t i =  (int32_t)0; i <  (int32_t)4; i++){
/* Temporary variable for sub-expression on source location: (19,34-19,39) */
Bit __tac_var5 = x2[i];
/* Temporary variable for sub-expression on source location: (19,46-19,51) */
Integer __tac_var6 = x1[i];
/* Temporary variable for sub-expression on source location: (19,46-19,62) */
Bit __tac_var7 = __tac_var6.operator>(threshold1);
/* Temporary variable for sub-expression on source location: (19,68-19,84) */
Bit __tac_var9 = __tac_var6.operator<(threshold2);
/* Temporary variable for sub-expression on source location: (19,45-19,85) */
Bit __tac_var10 = __tac_var7.operator&(__tac_var9);
/* Temporary variable for sub-expression on source location: (19,89-19,90) */
Integer __tac_var11 = Integer(bitlen,  (int32_t)1, PUBLIC);
/* Temporary variable for sub-expression on source location: (19,93-19,94) */
Integer __tac_var12 = Integer(bitlen,  (int32_t)0, PUBLIC);
/* Temporary variable for sub-expression on source location: (19,44-19,94) */
Integer __tac_var13 =  If(__tac_var10, __tac_var11, __tac_var12);
/* Temporary variable for sub-expression on source location: (19,33-19,101) */
Integer __tac_var15 =  If(__tac_var5, __tac_var13, __tac_var12);
resultfinal = resultfinal.operator+(__tac_var15);
}
return resultfinal;
}


int main(int argc, char** argv) {
parse_party_and_port(argv, &party, &port);
if(argc>3){
  ip=argv[3];
}
cout<<"Ip Address: "<<ip<<endl;
cout<<"Port: "<<port<<endl;
cout<<"Party: "<<(party==1? "CLIENT" : "SERVER")<<endl;
NetIO * io = new NetIO(party==ALICE ? nullptr : ip, port);
setup_semi_honest(io, party);


auto grid1 = make_vector<Integer>( (int32_t)4);
if ((party == BOB)) {
cout << ("Input grid1:") << endl;
}
/* Variable to read the clear value corresponding to the input variable grid1 at (25,2-25,37) */
uint32_t __tmp_in_grid1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
if ((party == BOB)) {
cin >> __tmp_in_grid1;
}
grid1[i0] = Integer(bitlen, __tmp_in_grid1, BOB);
}

auto bool1 = make_vector<Bit>( (int32_t)4);
if ((party == BOB)) {
cout << ("Input bool1:") << endl;
}
/* Variable to read the clear value corresponding to the input variable bool1 at (26,2-26,36) */
bool __tmp_in_bool1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
if ((party == BOB)) {
cin >> __tmp_in_bool1;
}
bool1[i0] = Bit(__tmp_in_bool1, BOB);
}

Integer randnum;
if ((party == BOB)) {
cout << ("Input randnum:") << endl;
}
/* Variable to read the clear value corresponding to the input variable randnum at (27,2-27,34) */
uint32_t __tmp_in_randnum;
if ((party == BOB)) {
cin >> __tmp_in_randnum;
}
randnum = Integer(bitlen, __tmp_in_randnum, BOB);

auto grid2 = make_vector<Integer>( (int32_t)4);
if ((party == ALICE)) {
cout << ("Input grid2:") << endl;
}
/* Variable to read the clear value corresponding to the input variable grid2 at (29,2-29,37) */
uint32_t __tmp_in_grid2;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
if ((party == ALICE)) {
cin >> __tmp_in_grid2;
}
grid2[i0] = Integer(bitlen, __tmp_in_grid2, ALICE);
}

auto bool2 = make_vector<Bit>( (int32_t)4);
if ((party == ALICE)) {
cout << ("Input bool2:") << endl;
}
/* Variable to read the clear value corresponding to the input variable bool2 at (30,2-30,36) */
bool __tmp_in_bool2;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
if ((party == ALICE)) {
cin >> __tmp_in_bool2;
}
bool2[i0] = Bit(__tmp_in_bool2, ALICE);
}

auto grid = make_vector<Integer>( (int32_t)4);
for (uint32_t i =  (int32_t)0; i <  (int32_t)4; i++){
/* Temporary variable for sub-expression on source location: (41,12-41,20) */
Integer __tac_var16 = grid1[i];
/* Temporary variable for sub-expression on source location: (41,21-41,29) */
Integer __tac_var17 = grid2[i];
grid[i] = __tac_var16.operator+(__tac_var17);
}

auto clientbool = make_vector<Bit>( (int32_t)4);

Integer thres = Integer(bitlen,  (int32_t)2, PUBLIC);

Integer t1 = Integer(bitlen,  (int32_t)3, PUBLIC);

Integer t2 = Integer(bitlen,  (int32_t)5, PUBLIC);
for (uint32_t i =  (int32_t)0; i <  (int32_t)4; i++){
/* Temporary variable for sub-expression on source location: (52,18-52,26) */
Bit __tac_var18 = bool1[i];
/* Temporary variable for sub-expression on source location: (52,27-52,35) */
Bit __tac_var19 = bool2[i];
clientbool[i] = __tac_var18.operator^(__tac_var19);
}

Integer result;

Bit firstcheck;
firstcheck=check1(clientbool, thres);
result=If(firstcheck, count(grid, clientbool, t1, t2), Integer(bitlen, (int32_t)0, PUBLIC));
/* Temporary variable for sub-expression on source location: (62,17-62,31) */
Integer __tac_var20 = result.operator-(randnum);
cout << ("Value of __tac_var20:") << endl;
cout << (__tac_var20.reveal<int32_t>(ALICE)) << endl;


finalize_semi_honest();
delete io; 
 
return 0;
}

